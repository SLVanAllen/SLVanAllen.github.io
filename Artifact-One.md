# Artifact 1
## Buffer Overflow


My first artifact is an assignment from CS405 Secure Coding. It was an assignment completed in Visual Studio in C++. The original program prompted the user for an input value of no more than 20 characters. When the user gave an input of greater than 20 characters, the program would overflow the buffer resulting in an account number being overwritten. The goal of the assignment was to prevent buffer overflow, notifying the user of occurrence. 
	
I chose to include this artifact in my ePortfolio because it is a simple concept that reiterates the importance of how and why it is necessary to follow secure coding practices. Buffer overflow can lead to a variety of issues from security to system crashes. Although in the original assignment I was able to prevent the buffer from overflowing, the input validation logic was in main and the buffer size was fixed. I wanted the program to be robust enough that it could actually be used in a real-world solution. For this reason, I chose to remove the input validation from main, make changes to allow for a buffer of any size, and implement a couple tests to ensure the input validation function works correctly. These enhancements make the program modular, reusable, and testable.
	
The course outcomes I planned to meet with this enhancement were met. Because the input validation logic is removed from main and in its own function, it is reusable. So, if this program were to expand at all, it would be easy to maintain and scale without worry of having multiple areas of input validation. The code is therefore easy to follow and understand, meeting program outcomes by employing strategies for building collaborative environments that enable diverse audiences to support organizational decision making in the field of computer science. I also met program outcome of developing a security mindset that anticipates adversarial exploits in software architecture and designs to expose potential vulnerabilities, mitigate design flaws, and ensure privacy and enhanced security of data and resources by not only preventing the buffer overflow as well as implementing tests for the input validation.
	
One update to my course outcomes coverage plan is that I was able to design and evaluate computing solutions that solve a given problem using algorithmic principles and computer science practices and standards appropriate to its solution, while managing the trade-offs involved in design choices. This program outcome was met by through the conscious decision to leave the check for an empty input, as discussed in my code review, inside of the loop. I chose to leave the empty check here instead of inside of the validation function because I wanted to keep the validation solely for the purpose of checking the length to keep from overwriting the buffer size. This is what promotes reusability and maintainability. Now, this function can be used anywhere to check buffer size without forcing the handling of an empty input in a case it may not be necessary. For this reason, this artifact not only aligns with program outcomes number 1 and 5, but outcome number 3 as well.

During the process of enhancing and modifying this artifact, I ran into a couple challenges. The first challenge I ran into was before I changed the fixed buffer size. At first, I did not think it necessary to change from using a fixed buffer size. However, while I was making my changes, I noticed that if I continued to use strncpy_s throughout the program, I would need to write duplicate lines of code. I felt this added to the complexity of how the program was written and left an opportunity for more errors. To simplify this, I chose to just take that possibility away by not using the fixed buffer. The other challenge I faced when enhancing my first artifact was writing the tests necessary to prove the validation logic. When I wrote my first tests, I was checking that bad input would cause the test fail and thinking that was definitive proof the validation logic is functioning correctly. But I realized that I needed to test the function not the actual input values. When checking the buffer size, using <= 20 characters instead of < 20 could accidentally allow for 20 characters. I realized that the security mindset is about testing the functions logic, not just if one value is bad or not because that is what shows consistency. Both of these challenges were stern reminders that to write reliable code, it is necessary to make intentional design choices and write tests that ensure clear and consistent logic.

### Original File
[Buffer Overflow](BufferOverflow.html)

### Enhancement
[Buffer Overflow Enhanced](bufferOverflowEnhanced.html)
